using LibSharpRetro;

namespace DamageCore;

public class Memory {
	public readonly Core Core;
	public readonly ICartridge Cartridge;

	public readonly byte[] VRam = new byte[0x2000];
	public readonly byte[] WRam = new byte[0x2000];
	public readonly byte[] HRam = new byte[0x7F];
	public readonly byte[] Oam = new byte[0xA0];

	// Bootix v2
	public readonly byte[] Bootrom = [
		0x31, 0xfe, 0xff, 0x21, 0xff, 0x9f, 0xaf, 0x32, 0xcb, 0x7c, 0x20, 0xfa, 0x0e, 0x11, 0x21, 0x26,
		0xff, 0x3e, 0x80, 0x32, 0xe2, 0x0c, 0x3e, 0xf3, 0x32, 0xe2, 0x0c, 0x3e, 0x77, 0x32, 0xe2, 0x11,
		0x04, 0x01, 0x21, 0x10, 0x80, 0x1a, 0xcd, 0xb8, 0x00, 0x1a, 0xcb, 0x37, 0xcd, 0xb8, 0x00, 0x13,
		0x7b, 0xfe, 0x34, 0x20, 0xf0, 0x11, 0xcc, 0x00, 0x06, 0x08, 0x1a, 0x13, 0x22, 0x23, 0x05, 0x20,
		0xf9, 0x21, 0x04, 0x99, 0x01, 0x0c, 0x01, 0xcd, 0xb1, 0x00, 0x3e, 0x19, 0x77, 0x21, 0x24, 0x99,
		0x0e, 0x0c, 0xcd, 0xb1, 0x00, 0x3e, 0x91, 0xe0, 0x40, 0x06, 0x10, 0x11, 0xd4, 0x00, 0x78, 0xe0,
		0x43, 0x05, 0x7b, 0xfe, 0xd8, 0x28, 0x04, 0x1a, 0xe0, 0x47, 0x13, 0x0e, 0x1c, 0xcd, 0xa7, 0x00,
		0xaf, 0x90, 0xe0, 0x43, 0x05, 0x0e, 0x1c, 0xcd, 0xa7, 0x00, 0xaf, 0xb0, 0x20, 0xe0, 0xe0, 0x43,
		0x3e, 0x83, 0xcd, 0x9f, 0x00, 0x0e, 0x27, 0xcd, 0xa7, 0x00, 0x3e, 0xc1, 0xcd, 0x9f, 0x00, 0x11,
		0x8a, 0x01, 0xf0, 0x44, 0xfe, 0x90, 0x20, 0xfa, 0x1b, 0x7a, 0xb3, 0x20, 0xf5, 0x18, 0x49, 0x0e,
		0x13, 0xe2, 0x0c, 0x3e, 0x87, 0xe2, 0xc9, 0xf0, 0x44, 0xfe, 0x90, 0x20, 0xfa, 0x0d, 0x20, 0xf7,
		0xc9, 0x78, 0x22, 0x04, 0x0d, 0x20, 0xfa, 0xc9, 0x47, 0x0e, 0x04, 0xaf, 0xc5, 0xcb, 0x10, 0x17,
		0xc1, 0xcb, 0x10, 0x17, 0x0d, 0x20, 0xf5, 0x22, 0x23, 0x22, 0x23, 0xc9, 0x3c, 0x42, 0xb9, 0xa5,
		0xb9, 0xa5, 0x42, 0x3c, 0x00, 0x54, 0xa8, 0xfc, 0x42, 0x4f, 0x4f, 0x54, 0x49, 0x58, 0x2e, 0x44,
		0x4d, 0x47, 0x20, 0x76, 0x31, 0x2e, 0x32, 0x00, 0x3e, 0xff, 0xc6, 0x01, 0x0b, 0x1e, 0xd8, 0x21,
		0x4d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x01, 0xe0, 0x50,
	];
	public bool BootromDisabled;

	public Memory(Core core, ICartridge cartridge) {
		Core = core;
		Cartridge = cartridge;
	}

	public void Write(ushort addr, byte value) {
		//Console.WriteLine($"MEMWRITE 0x{addr:X04} == 0x{value:X02}");
		switch(addr) {
			case <= 0x7FFF or >= 0xA000 and <= 0xBFFF:
				Cartridge.Write(addr, value);
				break;
			case <= 0x9FFF:
				VRam[addr - 0x8000] = value;
				break;
			case <= 0xDFFF: // TODO: Add bank switching for CGB mode
				WRam[addr - 0xC000] = value;
				break;
			case <= 0xFDFF:
				Write((ushort) (addr - 0x2000), value);
				break;
			case <= 0xFE9F:
				Oam[addr - 0xFE00] = value;
				break;
			case <= 0xFEFF:
				break;
			case 0xFF50:
				if(value != 0)
					BootromDisabled = true;
				break;
			case <= 0xFF7F or 0xFFFF:
				Core.IoWrite(addr, value);
				break;
			case <= 0xFFFE:
				HRam[addr - 0xFF80] = value;
				break;
		}
	}

	public byte Read(ushort addr, bool inter = false) {
		var value = addr switch {
			<= 0xFF when !BootromDisabled => Bootrom[addr],
			<= 0x7FFF or >= 0xA000 and <= 0xBFFF => Cartridge.Read(addr),
			<= 0x9FFF => VRam[addr - 0x8000],
			<= 0xDFFF => WRam[addr - 0xC000],
			<= 0xFDFF => Read((ushort) (addr - 0x2000)),
			<= 0xFE9F => Oam[addr - 0xFE00],
			<= 0xFEFF => 0,
			<= 0xFF7F or 0xFFFF => Core.IoRead(addr),
			<= 0xFFFE => HRam[addr - 0xFF80]
		};
		//if(!inter) Console.WriteLine($"MEMREAD 0x{addr:X04} == 0x{value:X02}");
		return (byte) value;
	}

	public byte[] ReadBlock(ushort addr, int length) =>
		Enumerable.Range(0, length).Select(i => Read((ushort) (addr + i), true)).ToArray();

	public void Write16(ushort addr, ushort value) {
		Write(addr, (byte) (value & 0xFF));
		Write((ushort) (addr + 1), (byte) (value >> 8));
	}

	public ushort Read16(ushort addr) =>
		(ushort) (Read(addr) | (Read((ushort) (addr + 1)) << 8));

	public void WriteBlock(ushort addr, byte[] data) =>
		data.ForEach((x, i) => Write((ushort) (addr + i), x));
}